// Copyright June Rhodes. All Rights Reserved.

#pragma once

#include "Net/DataChannel.h"
#include "RedpointEOSBuild/BuildEnvironment.h"

REDPOINT_EOS_CODE_GUARD_BEGIN()

#define EOS_CONTROL_CHANNEL_MESSAGE_MIN 40

// ----- Connection level messages -----

// Dedicated server has received the NMT_Hello message, and is requesting the client's certificate for the
// connection.

DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_RequestClientEphemeralKey,
    40,
    FString /* Server connection public key */,
    FString /* Signature of server connection public key, signed by dedicated server signing key */
);

// Client is sending back it's ephemeral public key.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverClientEphemeralKey,
    41,
    FString /* The packet data as generated by libhydrogen */
);

// Server has generated an AES symmetric key for the rest of the connection, and is handing it back
// to the client encrypted.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_SymmetricKeyExchange,
    42,
    FString /* The AES symmetric key encrypted with the client's public key to encrypt the rest of the session */
);

// ----- Login/beacon level messages -----

// The server is requesting the client's external platform credentials to verify their login. This control message can
// only be safely transferred over an encrypted connection.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_RequestClientToken, 43, FUniqueNetIdRepl /* Target User ID */);

// The client is delivering their token to the trusted dedicated server so it can authenticate them against the EOS
// backend. Trusted dedicated servers will call EOS_Connect_Login with these credentials, and may use them to e.g. read
// and write data to PDS on the player's behalf.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverClientToken,
    44,
    FUniqueNetIdRepl /* Target User ID */,
    FString /* Client Token Type */,
    FString /* Client Display Name */,
    FString /* Client Token */);

// We are asking the remote to prove that they're allowed to run as an unprotected peer, if they can do so.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_RequestTrustedClientProof,
    45,
    FUniqueNetIdRepl /* Target User ID */,
    FString /* EncodedNonce */,
    uint8 /* Anti-Cheat Implementation Type */);

// The client is responding with either the proof that they can run as an unprotected peer, or that they need to run
// protected.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverTrustedClientProof,
    46,
    FUniqueNetIdRepl /* Target User ID */,
    bool /* bCanProvideProof */,
    FString /* EncodedProof */,
    FString /* PlatformString */,
    bool /* bRequestMutualProofFromListenServer */,
    FString /* EncodedNonceForListenServer */,
    bool /* bSkipPeerRegistration */);

// The client or server is sending EAC anti-cheat data to the other.
//
// NOTE: We should probably optimize this data format, since the repls might be big if EAC sends lots of network
// messages. For client-server layouts it's fairly straightforward, we'd just need a connection ID for the server to
// distinguish which client it's sending messages to (this would be negotiated during connect per logged in
// FUniqueNetIdRepl). It's trickier for peer-to-peer (listen servers), because we need the EOS ID when sending and
// receiving messages. Also, all of this might be more complicated than it needs to be, since we're assuming the same
// control channel can have multiple NMT_Login requests for split-screen, but that might not hold true in practice.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_AntiCheatMessage,
    47,
    FUniqueNetIdRepl /* Source User ID */,
    FUniqueNetIdRepl /* Target User ID */,
    TArray<uint8> /* Anti Cheat Data */);

// The server is requesting the client's ID token to verify their login. This control message can
// only be safely transferred over an encrypted connection.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_RequestIdToken, 49, FUniqueNetIdRepl /* Target User ID */);

// The client is delivering their ID token to the trusted dedicated server so it can verify the token against the EOS
// backend.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverIdToken,
    50,
    FUniqueNetIdRepl /* Target User ID */,
    FString /* Client Token */);

// ----- Connection level messages -----

// Client has received the AES symmetric key and is enabling encryption.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_EnableEncryption, 51);

// ----- Login/beacon level messages -----

// The client is telling the listen server that they accepted the trusted client proof from the listen server, or
// they were able to verify that the listen server is protected by EAC.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_AcceptedMutualTrustedClientProof, 52, FUniqueNetIdRepl /* Target User ID */);

#define EOS_CONTROL_CHANNEL_MESSAGE_MAX 52

REDPOINT_EOS_CODE_GUARD_END()